export declare type ThenType<T> = T extends Promise<infer U> ? U : T;
export declare type Arguments<T> = T extends (...args: infer U) => any ? U : never;
export declare type ArgumentAtIndex<Func, Index extends keyof Arguments<Func>> = Arguments<Func>[Index];
export declare type FirstArgument<T> = ArgumentAtIndex<T, 0>;
export declare type MaybeFunctionReturnType<T> = T extends (...args: any[]) => infer U ? U : never;
export declare type ArrayElement<T> = T extends (infer U)[] ? U : never;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? DeepPartial<U>[] : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
export declare type IfEmptyObject<Obj, If, Else = never> = keyof Obj extends {
    length: 0;
} ? If : Else;
export declare type IfAllOptionalKeys<Obj, If, Else = never> = NonOptionalKeys<Obj> extends {
    length: 0;
} ? If : Else;
export declare type IfAllNullableKeys<Obj, If, Else = never> = NonNullableKeys<Obj> extends {
    length: 0;
} ? If : Else;
export declare type NonOptionalKeys<T> = {
    [K in keyof T]-?: undefined extends T[K] ? never : K;
}[keyof T];
export declare type NonNullableKeys<T> = {
    [K in keyof T]-?: null extends T[K] ? never : K;
}[keyof T];
export declare type NoInfer<T> = {
    [K in keyof T]: T[K];
} & T;
declare type ReactStatics = 'displayName' | 'getDerivedStateFromProps' | 'getDerivedStateFromErrors' | 'childContextTypes' | 'contextType' | 'contextTypes' | 'getDefaultProps' | 'propTypes';
export declare type NonReactStatics<T> = Pick<T, Exclude<keyof T, ReactStatics>>;
export declare type ExtendedWindow<T> = Window & typeof globalThis & T;
export {};
//# sourceMappingURL=types.d.ts.map