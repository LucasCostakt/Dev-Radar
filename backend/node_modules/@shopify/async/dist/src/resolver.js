"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function createResolver(_a) {
    var _this = this;
    var id = _a.id, load = _a.load;
    var resolved = null;
    var resolvePromise = null;
    var hasTriedSyncResolve = false;
    var resolvedId = id && id();
    return {
        get id() {
            return resolvedId;
        },
        get resolved() {
            if (resolved == null && !hasTriedSyncResolve) {
                hasTriedSyncResolve = true;
                resolved = resolvedId ? trySynchronousResolve(resolvedId) : null;
            }
            return resolved;
        },
        resolve: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resolvePromise = resolvePromise || resolve(load);
                        return [4 /*yield*/, resolvePromise];
                    case 1:
                        resolved = _a.sent();
                        return [2 /*return*/, resolved];
                }
            });
        }); },
    };
}
exports.createResolver = createResolver;
function resolve(load) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var resolved;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, load()];
                case 1:
                    resolved = _a.sent();
                    return [2 /*return*/, normalize(resolved)];
            }
        });
    });
}
function normalize(module) {
    if (module == null) {
        return null;
    }
    var value = typeof module === 'object' && 'default' in module ? module.default : module;
    return value == null ? null : value;
}
/* eslint-enable @typescript-eslint/camelcase */
// Webpack does not like seeing an explicit require(someVariable) in code
// because that is a dynamic require that it can’t resolve. This code
// obfuscates `require()` for the purpose of fooling Webpack, which is fine
// because we only want to use the `require()` in cases where Webpack
// is not the module bundler.
//
// If we ever reference `require` directly, Webpack complains. So, we first
// check global["require"], which works in Node. However, this doesn’t work
// in Jest when the test is set to simulate a browser, as global in that case
// in a Window object. There, we can only rely on module.require, which is
// actually supposed to be something different but in Jest is the same as
// the global require function.
var requireKey = 'require';
var nodeRequire = (typeof global === 'object' &&
    typeof global[requireKey] === 'function' &&
    global[requireKey]) ||
    (typeof module === 'object' &&
        typeof module[requireKey] === 'function' &&
        module[requireKey]) ||
    undefined;
// If we have an ID, we try to first use Webpack’s internal stuff
// to resolve the module. If those don’t exist, we know we aren’t
// inside of a Webpack bundle, so we try to use Node’s native resolution
// (which will work in environments like Jest’s test runner).
function tryRequire(id) {
    if (
    /* eslint-disable @typescript-eslint/camelcase */
    typeof __webpack_require__ === 'function' &&
        typeof __webpack_modules__ === 'object' &&
        __webpack_modules__[id]
    /* eslint-enable @typescript-eslint/camelcase */
    ) {
        try {
            return normalize(__webpack_require__(id));
        }
        catch (_a) {
            // Just ignore failures
        }
    }
    else if (typeof nodeRequire === 'function') {
        try {
            return normalize(nodeRequire(id));
        }
        catch (_b) {
            // Just ignore failures
        }
    }
    return undefined;
}
function trySynchronousResolve(id) {
    return tryRequire(id) || null;
}
