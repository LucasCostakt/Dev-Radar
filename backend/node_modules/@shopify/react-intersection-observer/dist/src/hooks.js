"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable react-hooks/exhaustive-deps */
var react_1 = require("react");
var utilities_1 = require("./utilities");
var types_1 = require("./types");
var emptyBoundingClientRect = {
    bottom: 0,
    height: 0,
    left: 0,
    right: 0,
    top: 0,
    width: 0,
};
function useIntersection(_a) {
    var _b = _a === void 0 ? {} : _a, root = _b.root, rootMargin = _b.rootMargin, threshold = _b.threshold, _c = _b.unsupportedBehavior, unsupportedBehavior = _c === void 0 ? types_1.UnsupportedBehavior.TreatAsIntersecting : _c;
    var node = react_1.useRef(null);
    var lastNode = react_1.useRef(null);
    var observer = react_1.useRef(null);
    var lastObserver = react_1.useRef(null);
    var _d = tslib_1.__read(react_1.useState(function () { return ({
        boundingClientRect: emptyBoundingClientRect,
        intersectionRatio: 0,
        intersectionRect: emptyBoundingClientRect,
        isIntersecting: false,
        rootBounds: emptyBoundingClientRect,
        target: null,
        time: Date.now(),
    }); }), 2), intersectionEntry = _d[0], setIntersectingEntry = _d[1];
    react_1.useEffect(function () {
        if (!utilities_1.isSupported()) {
            return;
        }
        var resolvedRoot = typeof root === 'string' ? document.querySelector(root) : root;
        var intersectionObserver = new IntersectionObserver(function (_a) {
            var _b = tslib_1.__read(_a, 1), entry = _b[0];
            return setIntersectingEntry(entry);
        }, {
            root: resolvedRoot,
            rootMargin: rootMargin,
            threshold: threshold,
        });
        observer.current = intersectionObserver;
        return function () {
            intersectionObserver.disconnect();
        };
    }, [
        root,
        rootMargin,
        Array.isArray(threshold) ? threshold.join() : threshold,
    ]);
    react_1.useEffect(function () {
        if (lastNode.current === node.current &&
            lastObserver.current === observer.current) {
            return;
        }
        lastNode.current = node.current;
        if (node.current == null) {
            return;
        }
        if (!utilities_1.isSupported() &&
            unsupportedBehavior === types_1.UnsupportedBehavior.TreatAsIntersecting) {
            var boundingClientRect = node.current.getBoundingClientRect();
            setIntersectingEntry({
                boundingClientRect: boundingClientRect,
                intersectionRatio: 1,
                intersectionRect: boundingClientRect,
                isIntersecting: true,
                rootBounds: boundingClientRect,
                target: node.current,
                time: Date.now(),
            });
            return;
        }
        if (observer.current != null) {
            lastObserver.current = observer.current;
            observer.current.observe(node.current);
        }
        return function () {
            if (lastNode.current == null ||
                lastObserver.current == null ||
                (lastNode.current === node.current &&
                    lastObserver.current === observer.current)) {
                return;
            }
            lastObserver.current.unobserve(lastNode.current);
        };
    });
    return [intersectionEntry, node];
}
exports.useIntersection = useIntersection;
function useValueTracking(value, onChange) {
    var tracked = react_1.useRef(value);
    var oldValue = tracked.current;
    if (value !== oldValue) {
        tracked.current = value;
        onChange(value, oldValue);
    }
}
exports.useValueTracking = useValueTracking;
/* eslint-enable react-hooks/exhaustive-deps */
