"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var server_1 = require("react-dom/server");
var context_1 = require("./context");
var manager_1 = require("./manager");
var Effect_1 = require("./Effect");
exports.Effect = Effect_1.Effect;
var DEFAULT_MAX_PASSES = 5;
function extract(app, _a) {
    var _b = _a === void 0 ? {} : _a, include = _b.include, _c = _b.maxPasses, maxPasses = _c === void 0 ? DEFAULT_MAX_PASSES : _c, _d = _b.decorate, decorate = _d === void 0 ? identity : _d, _e = _b.renderFunction, renderFunction = _e === void 0 ? server_1.renderToStaticMarkup : _e, betweenEachPass = _b.betweenEachPass, afterEachPass = _b.afterEachPass;
    var manager = new manager_1.EffectManager({ include: include });
    var element = (react_1.default.createElement(context_1.EffectContext.Provider, { value: manager }, decorate(app)));
    return (function perform(index) {
        if (index === void 0) { index = 0; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var start, result, cancelled, duration, resolveStart, renderDuration, resolveDuration, performNextPass, _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        start = Date.now();
                        result = renderFunction(element);
                        cancelled = !manager.finished && index + 1 >= maxPasses;
                        if (!(manager.finished || cancelled)) return [3 /*break*/, 4];
                        duration = Date.now() - start;
                        return [4 /*yield*/, manager.afterEachPass({
                                index: index,
                                finished: true,
                                cancelled: cancelled,
                                renderDuration: duration,
                                resolveDuration: 0,
                            })];
                    case 1:
                        _c.sent();
                        if (!afterEachPass) return [3 /*break*/, 3];
                        return [4 /*yield*/, afterEachPass({
                                index: index,
                                finished: true,
                                cancelled: cancelled,
                                renderDuration: duration,
                                resolveDuration: 0,
                            })];
                    case 2:
                        _c.sent();
                        _c.label = 3;
                    case 3: return [2 /*return*/, result];
                    case 4:
                        resolveStart = Date.now();
                        renderDuration = resolveStart - start;
                        return [4 /*yield*/, manager.resolve()];
                    case 5:
                        _c.sent();
                        resolveDuration = Date.now() - resolveStart;
                        performNextPass = true;
                        _a = shouldContinue;
                        return [4 /*yield*/, manager.afterEachPass({
                                index: index,
                                finished: false,
                                cancelled: false,
                                renderDuration: renderDuration,
                                resolveDuration: resolveDuration,
                            })];
                    case 6:
                        performNextPass =
                            _a.apply(void 0, [_c.sent()]) && performNextPass;
                        if (!afterEachPass) return [3 /*break*/, 8];
                        _b = shouldContinue;
                        return [4 /*yield*/, afterEachPass({
                                index: index,
                                finished: false,
                                cancelled: false,
                                renderDuration: renderDuration,
                                resolveDuration: resolveDuration,
                            })];
                    case 7:
                        performNextPass =
                            _b.apply(void 0, [_c.sent()]) && performNextPass;
                        _c.label = 8;
                    case 8:
                        if (!performNextPass) return [3 /*break*/, 11];
                        return [4 /*yield*/, manager.betweenEachPass({
                                index: index,
                                finished: false,
                                cancelled: false,
                                renderDuration: renderDuration,
                                resolveDuration: resolveDuration,
                            })];
                    case 9:
                        _c.sent();
                        if (!betweenEachPass) return [3 /*break*/, 11];
                        return [4 /*yield*/, betweenEachPass({
                                index: index,
                                finished: false,
                                cancelled: false,
                                renderDuration: renderDuration,
                                resolveDuration: resolveDuration,
                            })];
                    case 10:
                        _c.sent();
                        _c.label = 11;
                    case 11:
                        manager.reset();
                        return [2 /*return*/, performNextPass ? perform(index + 1) : result];
                }
            });
        });
    })();
}
exports.extract = extract;
function shouldContinue(result) {
    return result !== false;
}
function identity(value) {
    return value;
}
